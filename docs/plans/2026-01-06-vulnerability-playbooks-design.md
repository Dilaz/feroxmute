# Vulnerability Playbooks Design

## Overview

Expand Scanner and Exploit agent knowledge with detailed vulnerability playbooks. Agents receive a condensed index in their prompts and fetch full playbooks on-demand via a new `get_playbook` tool.

## Goals

- Comprehensive coverage of 17 vulnerability categories
- Detailed step-by-step workflows for each vulnerability class
- Tool-specific guidance including Metasploit exploitation
- Windows attack coverage (web vectors + Active Directory)

## Architecture

### File Structure

```
feroxmute-core/
├── prompts.toml           # Add playbook index to Scanner/Exploit prompts
├── playbooks/
│   ├── index.toml         # Playbook metadata and categories
│   ├── sql-injection.md
│   ├── xss.md
│   ├── csrf.md
│   ├── command-injection.md
│   ├── jwt-attacks.md
│   ├── xxe.md
│   ├── lfi-rfi.md
│   ├── ssti.md
│   ├── ssrf.md
│   ├── deserialization.md
│   ├── race-conditions.md
│   ├── nosql-injection.md
│   ├── graphql.md
│   ├── websockets.md
│   ├── windows-web.md
│   ├── windows-ad.md
│   └── crypto.md
└── src/tools/
    └── playbook.rs         # New GetPlaybookTool
```

### How It Works

1. Scanner/Exploit prompts include a condensed index mapping vulnerability types to indicators and tools
2. When testing a specific vulnerability class, agent calls `get_playbook("sql-injection")`
3. Tool returns full playbook content with detailed techniques, payloads, and workflows
4. Playbooks are embedded in the binary at compile time via `include_str!`

## Components

### GetPlaybookTool

```rust
pub struct GetPlaybookTool;

impl GetPlaybookTool {
    const PLAYBOOKS: &[(&str, &str)] = &[
        ("sql-injection", include_str!("../../playbooks/sql-injection.md")),
        ("xss", include_str!("../../playbooks/xss.md")),
        ("csrf", include_str!("../../playbooks/csrf.md")),
        ("command-injection", include_str!("../../playbooks/command-injection.md")),
        ("jwt-attacks", include_str!("../../playbooks/jwt-attacks.md")),
        ("xxe", include_str!("../../playbooks/xxe.md")),
        ("lfi-rfi", include_str!("../../playbooks/lfi-rfi.md")),
        ("ssti", include_str!("../../playbooks/ssti.md")),
        ("ssrf", include_str!("../../playbooks/ssrf.md")),
        ("deserialization", include_str!("../../playbooks/deserialization.md")),
        ("race-conditions", include_str!("../../playbooks/race-conditions.md")),
        ("nosql-injection", include_str!("../../playbooks/nosql-injection.md")),
        ("graphql", include_str!("../../playbooks/graphql.md")),
        ("websockets", include_str!("../../playbooks/websockets.md")),
        ("windows-web", include_str!("../../playbooks/windows-web.md")),
        ("windows-ad", include_str!("../../playbooks/windows-ad.md")),
        ("crypto", include_str!("../../playbooks/crypto.md")),
    ];
}

#[derive(Debug, Deserialize, JsonSchema)]
pub struct GetPlaybookInput {
    /// Vulnerability category (e.g., "sql-injection", "jwt-attacks")
    pub category: String,
}

impl Tool for GetPlaybookTool {
    const NAME: &'static str = "get_playbook";

    type Input = GetPlaybookInput;
    type Output = String;
    type Error = PlaybookError;

    async fn call(&self, input: Self::Input) -> Result<Self::Output, Self::Error> {
        Self::PLAYBOOKS
            .iter()
            .find(|(name, _)| *name == input.category)
            .map(|(_, content)| content.to_string())
            .ok_or(PlaybookError::NotFound(input.category))
    }
}
```

Available to: Scanner and Exploit agents only.

### Prompt Index

Added to Scanner and Exploit prompts in `prompts.toml`:

```toml
## Vulnerability Playbooks

Call `get_playbook(category)` for detailed techniques. Quick reference:

| Category | Indicators | Primary Tools |
|----------|-----------|---------------|
| sql-injection | Error messages, numeric params, login forms | sqlmap, manual UNION/blind |
| xss | Reflected input, innerHTML, document.write | dalfox, manual |
| csrf | State-changing POST, no token validation | manual |
| command-injection | Shell chars in params, ping/curl delays | commix, manual |
| jwt-attacks | Bearer tokens, alg header, weak secrets | jwt_tool, hashcat |
| xxe | XML upload, SOAP, Office files, SVG | manual, xxeinjector |
| lfi-rfi | File params, path=, include=, lang= | manual, ffuf |
| ssti | Template syntax in output, {{7*7}}=49 | tplmap, manual |
| ssrf | URL params, webhooks, image fetch | manual, collaborator |
| deserialization | Serialized objects, magic bytes, gadgets | ysoserial, manual |
| race-conditions | Concurrent requests, TOCTOU, limits | turbo intruder, python |
| nosql-injection | MongoDB queries, $where, $regex | nosqlmap, manual |
| graphql | Introspection, batching, nested queries | graphql-voyager, manual |
| websockets | WS connections, no origin check | wscat, manual |
| windows-web | IIS, NTLM prompts, UNC paths | responder, ntlmrelayx |
| windows-ad | Domain joined, SPNs, Kerberos | impacket, crackmapexec, msf |
| crypto | Weak hashing, padding, key reuse | hashcat, john, manual |

When you identify potential vulnerability indicators, fetch the playbook before testing.
```

### Playbook Content Structure

Each playbook follows a consistent format:

```markdown
# [Vulnerability] Playbook

## Indicators
Signs this vulnerability may be present:
- Indicator 1
- Indicator 2
- Indicator 3

## Tools

### [Primary Tool]
```bash
# Basic usage
command --flags

# Advanced usage
command --more-flags
```

### [Secondary Tool]
...

### Manual Testing
```bash
# Manual techniques
curl "payload"
```

## Techniques

### 1. [Technique Name]
Step-by-step workflow with commands and expected output.

### 2. [Technique Name]
...

## Metasploit Modules
```bash
use auxiliary/module/path
set RHOSTS target
run

use exploit/module/path
set PAYLOAD payload/type
exploit
```

## Bypass Techniques
- Bypass 1: Description and payload
- Bypass 2: Description and payload

## Success Indicators
- How to confirm exploitation worked
- Evidence to capture
- Impact demonstration
```

## Agent Usage Patterns

### Scanner Agent

Focus: Detection and validation

1. Identify indicators from prompt index
2. Call `get_playbook("category")`
3. Use "Techniques" section to confirm vulnerability exists
4. Record finding with evidence
5. Move to next target area

Scanner stops at: "This is exploitable" with proof.

Prompt addition:
> "Use playbooks to confirm vulnerabilities. Stop at validated finding with evidence."

### Exploit Agent

Focus: Impact demonstration and PoC development

1. Receive vulnerability claim from Scanner
2. Call `get_playbook("category")`
3. Use "Techniques" to reproduce
4. Escalate using advanced techniques
5. Use Metasploit if applicable for full exploitation
6. Document complete attack chain with PoC

Exploit continues to: "Here's exactly what an attacker could achieve" with working PoC.

Prompt addition:
> "Use playbooks to demonstrate full impact. Develop working PoCs. Use Metasploit for exploitation where appropriate."

## Playbook Summary

| Playbook | Primary Tools | Key Techniques |
|----------|--------------|----------------|
| `sql-injection.md` | sqlmap, manual | UNION, blind, time-based, error-based |
| `xss.md` | dalfox, manual | Reflected, stored, DOM, filter bypass |
| `csrf.md` | manual | Token bypass, SameSite bypass, clickjacking combo |
| `command-injection.md` | commix, manual | OS detection, blind, out-of-band |
| `jwt-attacks.md` | jwt_tool, hashcat | alg:none, weak secret, key confusion |
| `xxe.md` | manual | File read, SSRF via XXE, blind XXE, Office/SVG |
| `lfi-rfi.md` | manual, ffuf | Path traversal, null byte, wrappers, log poisoning |
| `ssti.md` | tplmap, manual | Jinja2, Twig, Freemarker, Pebble detection |
| `ssrf.md` | manual | Cloud metadata, internal scanning, protocol smuggling |
| `deserialization.md` | ysoserial, manual | Java, PHP, Python, .NET gadget chains |
| `race-conditions.md` | turbo intruder, python | TOCTOU, limit bypass, double-spend |
| `nosql-injection.md` | nosqlmap, manual | MongoDB, operator injection, JS injection |
| `graphql.md` | graphql-voyager, manual | Introspection, batching, depth attacks |
| `websockets.md` | manual, wscat | CSWSH, injection, hijacking |
| `windows-web.md` | responder, ntlmrelayx | NTLM capture, UNC injection, LDAP injection |
| `windows-ad.md` | impacket, crackmapexec, msf | Kerberoasting, AS-REP, DCSync, PTH, PTT |
| `crypto.md` | hashcat, john, manual | Weak hashing, padding oracle, key reuse |

## Docker Container Updates

The Kali Docker image needs additional tools for playbook support.

### Dockerfile Additions

**APT packages (available in Kali repos):**
```dockerfile
RUN apt-get update && apt-get install -y \
    # ... existing packages ...
    metasploit-framework \
    responder \
    hashcat \
    john \
    commix \
    && rm -rf /var/lib/apt/lists/*
```

**Python packages via uv:**
```dockerfile
RUN uv pip install --system --break-system-packages \
    impacket \
    crackmapexec \
    jwt-tool \
    tplmap \
    nosqlmap
```

**Go-based tools:**
```dockerfile
RUN go install github.com/hahwul/dalfox/v2@latest
```

**Java tools (ysoserial):**
```dockerfile
RUN mkdir -p /opt/ysoserial && \
    wget -O /opt/ysoserial/ysoserial.jar \
    https://github.com/frohoff/ysoserial/releases/latest/download/ysoserial-all.jar
```

**Note:** metasploit-framework is large (~1GB+). This will significantly increase container size from current ~2-3GB to ~4-5GB.

## Implementation Order

1. Create `playbooks/` directory structure
2. Implement `GetPlaybookTool` in `src/tools/playbook.rs`
3. Register tool with Scanner and Exploit agents
4. Add playbook index to Scanner and Exploit prompts
5. Write all 17 playbook files
6. Update Dockerfile with new tools
7. Test end-to-end with sample engagement

## Testing Strategy

1. Unit tests for `GetPlaybookTool` (valid category, invalid category)
2. Integration test: Scanner agent fetches playbook and uses techniques
3. Manual test: Full engagement with playbook-guided vulnerability discovery
